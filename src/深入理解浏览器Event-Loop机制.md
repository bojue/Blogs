# 深入理解浏览器Event-Loop机制

Web浏览器基于单线程执行执行模式，在同一时刻只能执行一个任务，只有当前事件处理完成之后才能执行其他事件。

#### 事件循环

浏览器通过事件队列和事件循环来处理事件，事件队列分为两种：宏队列和微队列。浏览器Event-Loop机制是处理宏队列和微队列的过程。

+ 宏任务是离散的独立任务，比如创建DOM对象，执行全局JavaScript代码，解析HTML文档，页面加载，定时器事件，宏任务执行完成之后可以执行其他事件，比如浏览器垃圾回收。

+ 微任务是更小的任务，在其他任务执行之前执行，比如Promise执行方法，微任务一般通过异步执行或者需要立即执行的并且不产全新的微任务的事件。微任务是在浏览器UI重新渲染之前执行。

事件循环通过两个原则处理浏览器事件，一是单线程处理方式，二是事件在执行过程中不会被其他事件中断（除非浏览器自己决定主动终端某个事件，比如浏览器主动关闭一些处理事件时间过长的事件进程，一般很少发生）。

事件循环过程：

1. 事件循环首先检查宏队列列表，如果队列存在等待宏任务，则执行（2）。否则直接执行（3）

2. 执行宏任务列表的第1个等待处理事件，执行完成从宏任务队列移除该事件，执行（3）
3. 执行微任务列表的第1个处理事件，处理完成从微任务列表移除该事件，如果还有等待的微任务，则重复（3）直到微任务列表为空，否则直接执行（4）
4. 检查是否需要更新UI视图，如果是则重新渲染UI视图，否则返回（1）开始新的循环过程。

在事件循环一个完整的迭代过程中，宏任务最多只执行一次，微任务则全部被执行，微任务主要目的是为了在下一次页面重绘之前更新程序状态。

事件循环过程中微任务优先处理，微任务列表执行完成之前，不允许浏览器UI渲染，所以说浏览器渲染UI渲染发生在两个宏任务之间，并且微任务列表为空。

我们可以将事件设置成微任务阻止浏览器UI渲染。

Web浏览器的事件队列的循环检查和添加是两个完全独立的过程，确保在事件循环过程中浏览器可以执行其他事件操作，并且将浏览器新监听到的事件添加到当前事件队列中去，当前执行的事件处理不受影响。











